grammar edu.ksu.cis.projects.mdcf.devicemodel.DeviceModelingLanguage hidden(WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate deviceModelingLanguage "http://mdcf.projects.cis.ksu.edu/devicemodel/DeviceModelingLanguage"

Model:               decls+=Decl*;
	
Decl:                TypeDecl | FeaturesDecl; 
                       
TypeDecl:            'type' name=ID
                       ( 'include' supers+=[TypeDecl|ID] ( ',' supers+=[TypeDecl|ID] )* )?
                       ( '{' ( elems+=ELiteral ( ',' elems+=ELiteral )* )? '}' )?;
	                   
FeaturesDecl:        (complete='complete')? 'features' name=ID
                       ( 'include' supers+=[FeaturesDecl|ID] ( ',' supers+=[FeaturesDecl|ID] )* )?  
                       body=FeaturesBody;

FeaturesBody:        {FeaturesBody} ( '{' features += FeatureDecl* '}' )?;

FeatureDecl:         InvariantDecl | AttrDecl | SubFeaturesDecl;

InvariantDecl:       MultiplicityInvariantDecl;

MultiplicityInvariantDecl: 
	                   'inv' ( invName=ID ':' )? ( lo=ConstraintNat '..' hi=ConstraintNat ) 
	                     match=SubFeaturesMatch 
	                     ( ':' type=[FeaturesDecl|ID] )?;

SubFeaturesMatch:    {SubFeaturesMatch} ( distinct='distinct' )? 
                       ( categoryNames+=ID '.' )* ( name=ID | any='*' );

ConstraintNat:       {NumNatConstraint} num=NAT | {AnyNatConstraint} '*' ;	                     

AttrDecl:            modifier=Modifier attributeName=ID 
	                     ( ':' type=Type 
	                     | '=' literal=Literal );

Modifier:            'const' | 'val' | 'var' | 'def';

Type:                ( {BasicType} baseType=[TypeDecl|ID]
	                       ( {ListType.base=current} '[' ']'
	                       | {SetType.base=current}  '{' '}' )*
                       | '<' {TupleType} elemTypes+=Type ( '*' elemTypes+=Type )+ '>'
                     ) ( '?' {OptionType.base=current} )?;
 
Literal:             BasicLiteral | TupleLiteral | ListLiteral | SetLiteral | OptionLiteral;

BasicLiteral:        typeCons=[TypeDecl|ID] lit=LIT;

TupleLiteral:        '<' {TupleLiteral} ( elems+=Literal ( ',' elems+=Literal)* )? '>';

ListLiteral:         typeCons=[TypeDecl|ID] '[' ( elems+=ELiteral ( ',' elems+=ELiteral)* )? ']';

SetLiteral:          typeCons=[TypeDecl|ID] '{' ( elems+=ELiteral ( ',' elems+=ELiteral)* )? '}';

OptionLiteral:         'none' {NoneLiteral} ':' type=Type
                     | 'some' {SomeLiteral} lit=Literal;

ELiteral:            lit=LIT;

SubFeaturesDecl:     ( categoryNames+=ID '.' )* name=ID type=SubFeaturesType;

SubFeaturesType:       ':' {SubGroupTypeRef}  type=[FeaturesDecl|ID] 
                     | {SubGroupTypeAnon} 
                       ( 'include' supers+=[FeaturesDecl|ID] 
                     	      ( ',' supers+=[FeaturesDecl|ID] )*
                       )? 
                       '=' body=FeaturesBody;

terminal ID:         '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;

terminal LIT:        '(' -> ')';
terminal NAT:        '0' | ('1'..'9') ('0'..'9')*;

terminal ML_COMMENT: '/*' -> '*/';
terminal SL_COMMENT: '//' !('\n'|'\r')* ('\r'? '\n')?;
terminal WS:         (' '|'\t'|'\r'|'\n')+;
