grammar edu.ksu.cis.projects.mdcf.devicemodel.DeviceModelingLanguage hidden(WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate deviceModelingLanguage "http://mdcf.projects.cis.ksu.edu/devicemodel/DeviceModelingLanguage"

Model:               decls+=Decl*;
	
Decl:                TypeDecl | FeaturesDecl; 
                       
TypeDecl:            'type' name=ID
                       ( 'include' supers+=[TypeDecl|ID] ( ',' supers+=[TypeDecl|ID] )* )?
                       ( '{' ( elems+=LIT ( ',' elems+=LIT )* )? '}' )?;
	                   
FeaturesDecl:        (complete='complete')? 'features' name=ID
                       ( 'include' supers+=[FeaturesDecl|ID] ( ',' supers+=[FeaturesDecl|ID] )* )?  
                       body=FeaturesBody;

FeaturesBody:        {FeaturesBody} ( '{' features += FeatureDecl* '}' )?;

FeatureDecl:         SubFeaturesDecl | InvariantDecl | AttrDecl;


SubFeaturesDecl:     ( categoryNames+=ID '.' )* name=ID type=SubFeaturesType;

SubFeaturesType:       ':' {SubGroupTypeRef}  type=[FeaturesDecl|ID] 
                     | {SubGroupTypeAnon} 
                       ( 'include' supers+=[FeaturesDecl|ID] 
                            ( ',' supers+=[FeaturesDecl|ID] )*
                       )? 
                       '=' body=FeaturesBody;

InvariantDecl:       MultiplicityInvariantDecl;

MultiplicityInvariantDecl: 
	                   'inv' ( invName=ID ':' )? ( lo=ConstraintNat '..' hi=ConstraintNat ) 
	                     match=SubFeaturesMatch 
	                     ( ':' type=[FeaturesDecl|ID] )?;

SubFeaturesMatch:    {SubFeaturesMatch} ( distinct='distinct' )? 
                       ( categoryNames+=ID '.' )* ( name=ID | any='*' );

ConstraintNat:       {NumNatConstraint} num=NAT | {AnyNatConstraint} '*' ;	                     

AttrDecl:            modifier=Modifier attributeName=ID 
	                     ( ':' type=Type 
	                     | '=' literal=Literal );

Modifier:            'const' | 'val' | 'var' | 'def';

Type:                BasicType
                       ( 
	                       ( {ListType.base=current} '[' ']'
	                       | {SetType.base=current}  '{' '}' )+
                         ( '?' {OptionType.base=current} )?
                       )?;

BasicType:           ( baseType=[TypeDecl|ID]
                       | '<' {TupleType} elemTypes+=Type ( '*' elemTypes+=Type )+ '>')
                     ( '?' {OptionType.base=current} )?;
 
Literal:             BasicLiteral | TupleLiteral | ListLiteral | SetLiteral | OptionLiteral;

BasicLiteral:        typeCons=[TypeDecl|ID] lit=LIT;

TupleLiteral:        '<' {TupleLiteral} ( elems+=Literal ( ',' elems+=Literal)* )? '>';

ListLiteral:         '[' basicType=BasicType ':' ( elems+=SimpleLiteral ( ',' elems+=SimpleLiteral)* )? ']';

SetLiteral:          '{' basicType=BasicType ':' ( elems+=SimpleLiteral ( ',' elems+=SimpleLiteral)* )? '}';

OptionLiteral:         'none' {NoneLiteral} ':' type=Type
                     | 'some' {SomeLiteral} lit=Literal;

SimpleLiteral:         SimpleBasicLiteral | SimpleTupleLiteral
                     | SimpleListLiteral | SimpleSetLiteral | SimpleOptionLiteral;

SimpleBasicLiteral:  lit=LIT;

SimpleTupleLiteral:  '<' {SimpleTupleLiteral} ( elems+=SimpleLiteral ( ',' elems+=SimpleLiteral)* )? '>';

SimpleOptionLiteral:   'none' {SimpleNoneLiteral}
                     | 'some' {SimpleSomeLiteral} lit=SimpleLiteral;

SimpleListLiteral:   '[' {SimpleListLiteral} ( elems+=SimpleLiteral ( ',' elems+=SimpleLiteral)* )? ']';

SimpleSetLiteral:    '{' {SimpleSetLiteral} ( elems+=SimpleLiteral ( ',' elems+=SimpleLiteral)* )? '}';

terminal ID:         '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;

terminal LIT:        '(' -> ')';
terminal NAT:        '0' | ('1'..'9') ('0'..'9')*;

terminal ML_COMMENT: '/*' -> '*/';
terminal SL_COMMENT: '//' !('\n'|'\r')* ('\r'? '\n')?;
terminal WS:         (' '|'\t'|'\r'|'\n')+;
